<!DOCTYPE html>
<html lang="zh"><head>
  <meta charset="utf-8">
  <title>链表设计</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Xiak&#39;s Blog">
  <meta name="author" content="Xiak">
  <meta name="generator" content="Hugo 0.81.0" />
  
  
  <meta property="og:image" content="https://xiak.com/images/blog/cafe.jpg" />
  
  <meta property="og:title" content="链表设计" />
<meta property="og:description" content="Leetcode 链接 707. 设计链表 题干 设计链表的实现。您可以选择使用单链表或双" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiak.com/algorithm/list/" /><meta property="article:section" content="algorithm" />
<meta property="article:published_time" content="2021-03-19T15:30:00&#43;08:00" />
<meta property="article:modified_time" content="2021-03-19T15:30:00&#43;08:00" />


  

  <!-- plugins -->
  
  <link rel="stylesheet" href="https://xiak.com/plugins/bootstrap/bootstrap.min.css" media='screen'>
  
  <link rel="stylesheet" href="https://xiak.com/plugins/Ionicons/css/ionicons.min.css" >
  
  <link rel="stylesheet" href="https://xiak.com/plugins/magnific-popup/magnific-popup.min.css" >
  
  <link rel="stylesheet" href="https://xiak.com/plugins/slick/slick.css" >
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="https://xiak.com/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="https://xiak.com/images/favicon.png" type="image/x-icon">
  <link rel="icon" href="https://xiak.com/images/favicon.png" type="image/x-icon">

</head><body>
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->

<header class="navigation">
  <div class="container-fluid">
    <div class="row">
      <div class="col-md-12">
        
        <nav class="navbar">
          
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navigation">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
              <img src="https://xiak.com/images/logo.png" alt="XIAK | Community" width="100px" class="img-responsive">
            </a>
          </div>
          
          <div class="collapse navbar-collapse" id="navigation">
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="/">主页</a></li>
              
              
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true"
                  aria-expanded="false">博客 <span class="ion-ios-arrow-down"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/devops">DevOps</a></li>
                  
                  <li><a href="/algorithm">算法</a></li>
                  
                </ul>
              </li>
              
              
              
              <li><a href="/contact">联系我</a></li>
              
              

              
            </ul>
          </div>
        </nav>
      </div>
    </div>
  </div>
</header>

<section class="page-title bg-2" style="background-image: url('https://xiak.com/images/featue-bg.jpg');">
  <div class="container">
    <div class="row">
      <div class="col-md-12">
        <div class="block">
          <h1>链表设计</h1>
          <p></p>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="page-wrapper">
	<div class="container">
		<div class="row">
			<div class="col-md-8">
				<div class="post post-single">
					<h2 class="post-title">链表设计</h2>
					<div class="post-meta">
						<ul>
              <li><i class="ion-calendar"></i> March 19, 2021</li>
              <li><i class="ion-android-people"></i>
                提交人
                
                <a class="text-primary" href="/author/xiak">Xiak</a>
                
              </li>
              <li><i class="ion-pricetags"></i> 
                
                <a href="/tags/leetcode">Leetcode</a>
								
                , <a href="/tags/list">List</a>
								
              </li>
            </ul>
					</div>
					<div class="post-thumb">
						<img class="img-responsive" src="/images/blog/cafe.jpg" alt="链表设计">
					</div>
					<div class="post-content post-excerpt">
						<h3 id="leetcode-链接">Leetcode 链接</h3>
<p><a href="https://leetcode-cn.com/problems/design-linked-list/">707. 设计链表</a></p>
<h3 id="题干">题干</h3>
<p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p>
<p>在链表类中实现这些功能：</p>
<ul>
<li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
<li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
<li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li>
<li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
<li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p>示例:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="nx">MyLinkedList</span> <span class="nx">linkedList</span> <span class="p">=</span> <span class="nx">new</span> <span class="nf">MyLinkedList</span><span class="p">();</span>
<span class="nx">linkedList</span><span class="p">.</span><span class="nf">addAtHead</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">linkedList</span><span class="p">.</span><span class="nf">addAtTail</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="nx">linkedList</span><span class="p">.</span><span class="nf">addAtIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">//链表变为1-&gt; 2-&gt; 3
</span><span class="c1"></span><span class="nx">linkedList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>            <span class="c1">//返回2
</span><span class="c1"></span><span class="nx">linkedList</span><span class="p">.</span><span class="nf">deleteAtIndex</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>  <span class="c1">//现在链表是1-&gt; 3
</span><span class="c1"></span><span class="nx">linkedList</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>            <span class="c1">//返回3
</span></code></pre></div><p>提示:</p>
<blockquote>
<ul>
<li>所有 val 值都在 [1, 1000] 之内</li>
<li>操作次数将在 [1, 1000] 之内</li>
<li>请不要使用内置的 LinkedList 库</li>
</ul>
</blockquote>
<h3 id="思路">思路</h3>
<p>链表是底层的数据结构, 本文将会以清晰易懂的方式带领大家实现一个双向链表(每个节点都可以访问之前的节点和之后的节点), 我会把文章分为两部分</p>
<ul>
<li>
<p>数据结构设计</p>
</li>
<li>
<p>链表方法设计</p>
</li>
</ul>
<h4 id="数据结构设计">数据结构设计</h4>
<p>题目给出了一下结构体</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div><p>带头尾的双向链表则可以表示为</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">head</span> <span class="o">*</span><span class="nx">MyLinkedList</span>
    <span class="nx">tail</span> <span class="o">*</span><span class="nx">MyLinkedList</span>
    <span class="nx">pre</span>  <span class="o">*</span><span class="nx">MyLinkedList</span>
    <span class="nx">next</span> <span class="o">*</span><span class="nx">MyLinkedList</span>
    <span class="nx">val</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>可是这样设计好吗? 链表每个节点都必须存一个 <code>head</code> 和 <code>tail</code> 吗? 答案是否定的, 它们只需要存一次就够了, 那我们把上面结构体拆一下</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">ListNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">pre</span>  <span class="o">*</span><span class="nx">ListNode</span>
    <span class="nx">next</span> <span class="o">*</span><span class="nx">ListNode</span>
    <span class="nx">val</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">head</span>   <span class="o">*</span><span class="nx">ListNode</span>
    <span class="nx">tail</span>   <span class="o">*</span><span class="nx">ListNode</span>
    <span class="nx">length</span> <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div><p>把一个 <code>node</code> 必须的 <code>pre: 前置指针</code>, <code>next: 后置指针</code> 和 <code>val: 值</code> 独立为一个结构体 <code>ListNode</code>, 表示 <code>link list</code> 的一个节点</p>
<p>而 <code>MyLinkedList</code> 则专注存放链表属性 <code>head: 链表头节点</code>, <code>tail: 链表尾节点</code> 和 <code>length: 链表的长度</code></p>
<h4 id="链表方法设计">链表方法设计</h4>
<ul>
<li><code>Constructor()</code>: 初始化链表</li>
</ul>
<p>初始化带头尾的双向链表, 需要分别初始化头, 尾节点, 再把它们连接起来</p>
<p><img src="/images/algorithm/list-constructor.png" alt="list-constructor"></p>
<p>代码实现</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
    <span class="c1">// 初始化头
</span><span class="c1"></span>    <span class="nx">head</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span> <span class="p">{</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="c1">// 初始化尾
</span><span class="c1"></span>    <span class="nx">tail</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span> <span class="p">{</span> <span class="nx">head</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="c1">// 头尾连接
</span><span class="c1"></span>    <span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">tail</span>
    <span class="k">return</span> <span class="nx">MyLinkedList</span> <span class="p">{</span> 
        <span class="nx">head</span><span class="p">:</span> <span class="nx">head</span><span class="p">,</span> 
        <span class="nx">tail</span><span class="p">:</span> <span class="nx">tail</span><span class="p">,</span> 
        <span class="nx">length</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>AddAtHead(val)</code>: 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li>
</ul>
<p>在链表第一个元素之前插入节点, 也就是说在 <code>head</code> 节点值后, 在 <code>第一个节点</code> 之前插入节点</p>
<p>时间复杂度为 <code>O(1)</code>, 空间复杂度为 <code>O(1)</code></p>
<p><img src="/images/algorithm/list-add-node-at-head.png" alt="list-add-node-at-head"></p>
<p>代码实现</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinedList</span><span class="p">)</span> <span class="nf">AddAtHead</span> <span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 新节点, pre = this.head, next = this.head.next
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span> 
        <span class="nx">next</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span> 
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// 更新 head 和 第一个节点 的指针, 指向 new 节点
</span><span class="c1"></span>    <span class="nx">new</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>AddAtTail(val)</code>: 将值为 val 的节点追加到链表的最后一个元素。</li>
</ul>
<p>在链表最后一个元素之后插入节点, 即在 <code>tail</code> 之前, 在 <code>最后一个元素</code> 之后插入节点</p>
<p>时间复杂度为 <code>O(1)</code>, 空间复杂度为 <code>O(1)</code></p>
<p><img src="/images/algorithm/list-add-node-at-tail.png" alt="list-add-node-at-tail"></p>
<p>代码实现</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 新节点
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">pre</span><span class="p">,</span> 
        <span class="nx">next</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span> 
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span> 
    <span class="p">}</span>
    <span class="c1">// 更新 tail 和 最后一个节点的指针
</span><span class="c1"></span>    <span class="nx">new</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>

</code></pre></div><ul>
<li><code>AddAtIndex(index,val)</code>: 在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。</li>
</ul>
<p>在链表指定位置插入一个节点, 这种情况需要遍历链表</p>
<p>时间复杂度为 <code>O(n)</code>, 空间复杂度为 <code>O(1)</code></p>
<p><img src="/images/algorithm/list-add-node-at-index.png" alt="list-add-node-at-index"></p>
<p>代码实现</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果 index 长度大于链表长度 this.length, 不做操作
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 如果 index 长度等于链表长度, 在链表末尾添加此元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="o">==</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="nx">this</span><span class="p">.</span><span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 遍历链表, 让 cur 指针指向第 index 个节点
</span><span class="c1"></span>    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="c1">// 在第 index 个节点前插入新节点
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span><span class="p">,</span> 
        <span class="nx">next</span><span class="p">:</span> <span class="nx">cur</span><span class="p">,</span> 
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">new</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">new</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>DeleteAtIndex(index)</code>: 如果索引 index 有效，则删除链表中的第 index 个节点。</li>
</ul>
<p>在指定位置删除一个节点, 这种情况同样需要遍历</p>
<p>时间复杂度为 <code>O(n)</code>, 空间复杂度为 <code>O(1)</code></p>
<p><img src="/images/algorithm/list-delete-node-at-index.png" alt="list-delete-node-at-index"></p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 注意这里是 &gt;= (比如 100 个节点, index 范围为 0-99, 当 index == 100 时已经越界)
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 把 cur 指针指向第 index 个元素
</span><span class="c1"></span>    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">--</span>
<span class="p">}</span>
</code></pre></div><ul>
<li><code>Get(index)</code>: 获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li>
</ul>
<p>获取指定位置的节点信息, 需要遍历链表, 找到位置返回节点值即可</p>
<p>时间复杂度为 <code>O(n)</code>, 空间复杂度为 <code>O(1)</code></p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span> <span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span>
<span class="p">}</span>

</code></pre></div><h3 id="实现">实现</h3>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">list</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">ListNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">val</span>  <span class="kt">int</span>
	<span class="nx">pre</span>  <span class="o">*</span><span class="nx">ListNode</span>
	<span class="nx">next</span> <span class="o">*</span><span class="nx">ListNode</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyLinkedList</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">head</span>   <span class="o">*</span><span class="nx">ListNode</span>
	<span class="nx">tail</span>   <span class="o">*</span><span class="nx">ListNode</span>
	<span class="nx">length</span> <span class="kt">int</span>
<span class="p">}</span>


<span class="cm">/** Initialize your data structure here. */</span>
<span class="kd">func</span> <span class="nf">Constructor</span><span class="p">()</span> <span class="nx">MyLinkedList</span> <span class="p">{</span>
	<span class="c1">// 初始化头
</span><span class="c1"></span>    <span class="nx">head</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>	
    <span class="c1">// 初始化尾
</span><span class="c1"></span>    <span class="nx">tail</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">head</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="c1">// 头尾连接
</span><span class="c1"></span>    <span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">tail</span>
    <span class="k">return</span> <span class="nx">MyLinkedList</span> <span class="p">{</span> 
        <span class="nx">head</span><span class="p">:</span> <span class="nx">head</span><span class="p">,</span> 
        <span class="nx">tail</span><span class="p">:</span> <span class="nx">tail</span><span class="p">,</span> 
        <span class="nx">length</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>


<span class="cm">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="p">}</span>
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span>
<span class="p">}</span>


<span class="cm">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtHead</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1">// 新节点, pre = this.head, next = this.head.next
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">,</span>
        <span class="nx">next</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">,</span>
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// 更新 head 和 第一个节点 的指针, 指向 new 节点
</span><span class="c1"></span>    <span class="nx">new</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>


<span class="cm">/** Append a node of value val to the last element of the linked list. */</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1">// 新节点
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">pre</span><span class="p">,</span>
        <span class="nx">next</span><span class="p">:</span> <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">,</span>
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="c1">// 更新 tail 和 最后一个节点的指针
</span><span class="c1"></span>    <span class="nx">new</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>


<span class="cm">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">AddAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1">// 如果 index 长度大于链表长度 this.length, 不做操作
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="p">&gt;</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 如果 index 长度等于链表长度, 在链表末尾添加此元素
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="o">==</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="nx">this</span><span class="p">.</span><span class="nf">AddAtTail</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 遍历链表, 让 cur 指针指向第 index 个节点
</span><span class="c1"></span>    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="c1">// 在第 index 个节点前插入新节点
</span><span class="c1"></span>    <span class="nx">new</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ListNode</span><span class="p">{</span> 
        <span class="nx">pre</span><span class="p">:</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span><span class="p">,</span>
        <span class="nx">next</span><span class="p">:</span> <span class="nx">cur</span><span class="p">,</span>
        <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">new</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="nx">new</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">new</span>
    <span class="c1">// 链表长度加　1
</span><span class="c1"></span>    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">++</span>
<span class="p">}</span>


<span class="cm">/** Delete the index-th node in the linked list, if the index is valid. */</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">DeleteAtIndex</span><span class="p">(</span><span class="nx">index</span> <span class="kt">int</span><span class="p">)</span>  <span class="p">{</span>
    <span class="c1">// 注意这里是 &gt;= (比如 100 个节点, index 范围为 0-99, 当 index == 100 时已经越界)
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="c1">// 把 cur 指针指向第 index 个元素
</span><span class="c1"></span>    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="p">}</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">this</span><span class="p">.</span><span class="nx">length</span> <span class="o">--</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">this</span> <span class="o">*</span><span class="nx">MyLinkedList</span><span class="p">)</span> <span class="nf">Show</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">cur</span> <span class="o">:=</span> <span class="nx">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%d &#34;</span><span class="p">,</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">val</span><span class="p">)</span>
		<span class="nx">cur</span> <span class="p">=</span> <span class="nx">cur</span><span class="p">.</span><span class="nx">next</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\n&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="cm">/**
</span><span class="cm"> * Your MyLinkedList object will be instantiated and called as such:
</span><span class="cm"> * obj := Constructor();
</span><span class="cm"> * param_1 := obj.Get(index);
</span><span class="cm"> * obj.AddAtHead(val);
</span><span class="cm"> * obj.AddAtTail(val);
</span><span class="cm"> * obj.AddAtIndex(index,val);
</span><span class="cm"> * obj.DeleteAtIndex(index);
</span><span class="cm"> */</span>
</code></pre></div><h3 id="benchmark">Benchmark</h3>
<pre><code>执行用时: 28 ms
内存消耗: 7 MB
</code></pre><h3 id="leetcode-提交记录">Leetcode 提交记录</h3>
<p><a href="https://leetcode-cn.com/submissions/detail/157177919/">记录</a></p>

					</div>
					<div class="post-comments">
						
					</div>
				</div>
			</div>
      <div class="col-md-4">
        <aside class="sidebar"><div class="widget widget-latest-post">
    <h4 class="widget-title">最近提交</h4>
    
    <div class="media">
      <a class="pull-left" href="https://xiak.com/algorithm/daily-temperatures/">
        <img class="media-object" src="/images/blog/work.jpg" alt="739. 每日温度">
      </a>
      <div class="media-body">
        <h4 class="media-heading"><a href="https://xiak.com/algorithm/daily-temperatures/">739. 每日温度</a></h4>
        <p>Leetcode 链接 739. 每日温度 题干 请根据每日 气温 列表，重新生成一个列表。对</p>
      </div>
    </div>
    
    <div class="media">
      <a class="pull-left" href="https://xiak.com/algorithm/add-two-numbers-1/">
        <img class="media-object" src="/images/blog/work.jpg" alt="两数相加: 常规算法和原地算法">
      </a>
      <div class="media-body">
        <h4 class="media-heading"><a href="https://xiak.com/algorithm/add-two-numbers-1/">两数相加: 常规算法和原地算法</a></h4>
        <p>Leetcode 链接 2. 两数相加 题干 给你两个 非空 的链表，表示两个非负的整数。</p>
      </div>
    </div>
    
    <div class="media">
      <a class="pull-left" href="https://xiak.com/algorithm/calculator/">
        <img class="media-object" src="/images/blog/work.jpg" alt="面试题 16.26. 计算器">
      </a>
      <div class="media-body">
        <h4 class="media-heading"><a href="https://xiak.com/algorithm/calculator/">面试题 16.26. 计算器</a></h4>
        <p>Leetcode 链接 面试题 16.26. 计算器 题干 给定一个包含正整数、加(+)、减(-</p>
      </div>
    </div>
    
    <div class="media">
      <a class="pull-left" href="https://xiak.com/algorithm/list/">
        <img class="media-object" src="/images/blog/cafe.jpg" alt="链表设计">
      </a>
      <div class="media-body">
        <h4 class="media-heading"><a href="https://xiak.com/algorithm/list/">链表设计</a></h4>
        <p>Leetcode 链接 707. 设计链表 题干 设计链表的实现。您可以选择使用单链表或双</p>
      </div>
    </div>
    
  </div><div class="widget widget-category">
    <h4 class="widget-title">分类</h4>
    <ul class="widget-category-list">
      <li><a href="/categories/algorithm">Algorithm</a></li>
      <li><a href="/categories/devops">Devops</a></li>
    </ul>
  </div><div class="widget widget-tag">
    <h4 class="widget-title">标签</h4>
    <ul class="widget-tag-list">
      <li><a href="/tags/devops">Devops</a></li>
      <li><a href="/tags/interview">Interview</a></li>
      <li><a href="/tags/leetcode">Leetcode</a></li>
      <li><a href="/tags/linux">Linux</a></li>
      <li><a href="/tags/list">List</a></li>
      <li><a href="/tags/vmware">Vmware</a></li>
    </ul>
  </div></aside>

      </div>
		</div>
	</div>
</section>

<footer class="footer">
	<div class="container">
		<div class="row">
			<div class="col-md-12">
				<div class="footer-manu">
					<ul>
            
					</ul>
				</div>
				<p class="copyright">Copyright © 2021 XIAK 保留所有权利</p>
			</div>
		</div>
	</div>
</footer>






<script src="https://xiak.com/plugins/jQuery/jquery.min.js" ></script>

<script src="https://xiak.com/plugins/bootstrap/bootstrap.min.js" ></script>

<script src="https://xiak.com/plugins/slick/slick.min.js" ></script>

<script src="https://xiak.com/plugins/magnific-popup/magnific-popup.min.js" ></script>

<script src="https://xiak.com/plugins/shuffle/shuffle.min.js" ></script>

<script src="https://xiak.com/plugins/google-map/gmap.js" defer></script>




<script src="https://xiak.com/js/script.min.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	使用 cookies 可以提高本站的性能, 本站不会通过 cookies 获取用户任何信息, 是否同意使用 cookies <span id="js-cookie-button" class="btn btn-small btn-solid-border" style="margin: 10px">同意</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>

</html>